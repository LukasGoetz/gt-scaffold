\documentclass[a4paper,10pt,parskip]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage[lined,algoruled,linesnumbered]{algorithm2e}


\title{Treffen 07.11.2014}
\author{Dorle Osterode, Stefan Dang \& Lukas Götz}

\begin{document}

\maketitle{}

\section{Implementationsmöglichkeiten der benötigten Datentypen in Genometools}

Erste Ideen zur Implementierung der Datentypen fuer Scaffold-Graphen in C unter
Verwendung bestehender Datentypen aus Genome-Tools.

/* Scaffold-Graph */

typedef enum \{ VC\_UNIQUE, VC\_REPEAT,VC\_POLYMORPHIC, VC\_UNKNOWN \}
	 	VertexClass;\\
typedef enum \{ ED\_ANTISENSE, ED\_SENSE \} Direction;\\
typedef enum \{ EC\_REVERSE, EC\_SAME \} Composition;

/* Vertex */

struct GtScaffoldGraphVertex\\
\{\\
\begin{tabular}{l}
  /* eindeutige ID für den Knoten */\\
  GtUword id;\\
  /* Länge der Sequenz, die der Contig darstellt */\\
  GtUword seqlen;\\ 
  /* Wert der A-Statistik, um Contigs als REPEAT oder UNIQUE
     klassifizieren zu können;\\
     in Genom-Tools vom Typ float */\\
  float astat;\\	
  /* abgeschätzte Anzahl an Vorkommen des Contigs im Genom */\\
  float copynum;\\  
  /* zur Klassifikation des Knotens: REPEAT, UNIQUE, ... */\\
  VertexClass vertexclass;\\ 
  bool hasconflictinglink;\\
  GtUword nofedges;\\
  /* Sammlung von Kanten, die von dem Contig abgehen */\\
  struct GtScaffoldGraphEdge   **edges;\\  
  /* Markierung für Algorithmen; aus Genome-Tools entnommen siehe
  match/rdj-contigs-graph.c */\\
  GtContigsGraphMarks color;\\ 	  
\end{tabular}
\};

/* Edge */
struct GtScaffoldGraphEdge\\
\{\\
\begin{tabular}{l}
  /*  Knoten, zu dem die Kante führt */\\
  struct GtScaffoldGraphVertex *pend;\\ 
  /* Kante, die genau in die andere Richtung führt */\\
  struct GtScaffoldGraphEdge *ptwin;\\ 
  /* Informationen zu der Verbindung zwischen den Knoten */\\
  GtScaffoldGraphLink link;\\ 
  /* Markierung für Algorithmen */\\
  GtContigsGraphMarks color;\\ 
\end{tabular}
\};\\

/* Link */
struct GtScaffoldGraphLink\\
\{\\
\begin{tabular}{l}
  /* Id von dem Knoten auf den die Kante zeigt */\\
  GtUword id;\\ 	
  /* Länge der Sequenz des Contigs, auf den die Kante zeigt */\\
  GtUword seqlen;\\ 
  /*redundant ?*/\\

  /* Abschätzung der Entfernung der verbundenen Contigs */\\
  Gtword dist;\\
  /* Standardabweichung von der abgeschätzten Entfernung */\\
  float stddev;\\
  /* Anzahl der Distanzinformationen, die ein Anzeichen für die
  Verbindung der Contigs geben */\\
  GtUword numpairs;\\
  /* Typ der Verbindung: Distanz aus einer Eingabedatei\\
     (SLT-DISTANCEEST), (SLT-REFERENCE), (SLT-INFERRED),\\
     eine andere Verbindung (SLT-NOTYPE) */\\	    
  LinkType type;\\
  /* enthält die Richtung (Sense, Antisense) und welche\\
     Stränge die paired-Information enthalten (die gleiche\\
     Richtung oder das Reverse) */\\
  Direction direction;\\
  Composition composition;
\end{tabular}
\};

/* Graph */
struct GtScaffoldGraph\\
\{\\
\begin{tabular}{l}
  struct GtScaffoldGraphVertex **vertices;\\
  GtUword nofvertices;
\end{tabular}
\};

\section{Verfeinerung des Algorithmus zur Filterung der Knoten}

\begin{itemize}
\item graph.visit() Funktion durchläuft alle Knoten (HashMap) und ruft
  auf jedem Knoten die übergebene Vistor-Funktion auf. Vorher wird
  previsit() und danach postvisit() aufgerufen. (Quelle
  ScaffoldGraph.h)
\item Es dürfte keine Probleme beim zusammenlegen der Filterfunktionen
  geben, da die Bedingungen nacheinander für jeden Knoten lokal
  geprüft werden können.
\item Es sollte beachtet werden, dass es gegebenfalls andere
  Ergebnisse geben könnte, wenn in einem späteren Schritt die vorher
  schon herausgefilterten Knoten noch beachtet werden.
\item Die repetitiven Knoten sollten schon bei der Konstruktion des
  Graphen herausgefiltert werden.
\item Die markierten Knoten und Kanten können nicht sofort gelöscht
  werden, da die restlichen Knoten noch nicht klassifiziert sind. Da
  die Klassifikation eines Knoten aber anhand aller Nachbarn
  durchgeführt wird, können die Knoten und Kanten noch nicht füher
  gelöscht werden.
\item Bei SGA wird gezählt, wie viele Knoten anhand welches Kriteriums
  gelöscht werden. Dies könnte auch noch eingebaut werden.
\end{itemize}

\begin{algorithm}[H]
  \ForEach{Knoten im Graph}{
    \ForEach{Kantenrichtung}{
      \ForEach{Kantenpaar in gleiche Richtung}{
        \If{Kantenpaar uneindeutig geordnet ist mit
           Wahrscheinlichkeit $>$ p-cutoff {\bf and}
           Summe der estCopyNum der zugehörigen
           Endknoten $<$ cn-cutoff ist}
          {Markiere Endknoten mit kleineren 
	   estCopyNum als polymorph. Markiere alle Sense-
           /Antisensekanten des polymorphen Knoten schwarz,
           so dass sie im nächsten Schritt nicht mitbeachtet
           werden.
           break\;}           
        }
       \If{Knoten ist polymorph}
         {break\;}
       \ForEach{Kantenpaar in gleiche Richtung}{
         Berechne Overlap von nicht-schwarzen Kantenpaar.\;
       }   
       \If{längster Overlap $>$ 400} {
	 Markiere alle Sense-/Antisensekanten rot\;       
      }
    }
  }
  Lösche alle markierten Knoten und Kanten\;
  \caption{Zusammengefasste Filterfunktion (Schritt 4a und 4b vereinigt)}
\end{algorithm}


\section{Notizen zu dem Layout-Algorithmus}

\begin{itemize}
\item terminale Knoten: Knoten, die nur SENSE oder ANTISENES Kanten
  haben (Quelle: ScaffoldAlgorithms)
\item Zusammenhangskomponenten-Funktion wird in
  StringGraph/GraphSearchTree.h definiert
\item beim Walk für den Scaffold wird zuerst für jede
  Zusammenhangskomponente jeder Pfad zwischen terminalen Knoten mit
  einer Breitensuche (ohne heuristische Auswahl der Reihenfolge der
  Kindsknoten) berechnet. Dabei wird die Pfadlänge (Gap-Größe)
  minimiert. Als Layout für eine Zusammenhangskomponente wird dann
  der Pfad mit der längsten Sequenz (ohne Gaps) gewählt. (Quelle:
  ScaffoldGraph und ScaffoldWalk)
\end{itemize}

\end{document}
