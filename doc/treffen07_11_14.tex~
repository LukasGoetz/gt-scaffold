\documentclass[a4paper,10pt,parskip]{scrartcl}
\usepackage[utf8]{inputenc}
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{placeins}
\usepackage[lined,algoruled,linesnumbered]{algorithm2e}

\usepackage[usenames,dvipsnames]{color}

\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

\lstset{ %
  backgroundcolor=\color{white},   % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
  basicstyle=\footnotesize,        % the size of the fonts that are used for the code
  breakatwhitespace=false,         % sets if automatic breaks should only happen at whitespace
  breaklines=true,                 % sets automatic line breaking
  captionpos=b,                    % sets the caption-position to bottom
  commentstyle=\color{blue},    % comment style
  deletekeywords={...},            % if you want to delete keywords from the given language
  escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
  extendedchars=true,              % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
%  frame=single,                    % adds a frame around the code
  keepspaces=true,                 % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
  keywordstyle=\color{OliveGreen},       % keyword style
  morekeywords={*,...},            % if you want to add more keywords to the set
  numbers=left,                    % where to put the line-numbers; possible values are (none, left, right)
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\tiny\color{mygray}, % the style that is used for the line-numbers
  rulecolor=\color{black},         % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
  showspaces=false,                % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
  showstringspaces=false,          % underline spaces within strings only
  showtabs=false,                  % show tabs within strings adding particular underscores
  stepnumber=2,                    % the step between two line-numbers. If it's 1, each line will be numbered
  stringstyle=\color{mymauve},     % string literal style
  tabsize=2,                       % sets default tabsize to 2 spaces
  title=\lstname                   % show the filename of files included with \lstinputlisting; also try caption instead of title
}


\title{Treffen 07.11.2014}
\author{Dorle Osterode, Stefan Dang \& Lukas Götz}

\begin{document}

\maketitle{}

\section{Implementationsmöglichkeiten der benötigten Datentypen in Genometools}

Erste Ideen zur Implementierung der Datentypen fuer Scaffold-Graphen in C unter
Verwendung bestehender Datentypen aus Genome-Tools.

\begin{lstlisting}[language=C]
/* Scaffold-Graph */

typedef enum { VC_UNIQUE, VC_REPEAT,VC_POLYMORPHIC, VC_UNKNOWN }
	 	VertexClass;
typedef enum { ED_ANTISENSE, ED_SENSE } Direction;
typedef enum { EC_REVERSE, EC_SAME } Composition;

/* Vertex */

struct GtScaffoldGraphVertex
{
  /* eindeutige ID fuer den Knoten */
  GtUword id;
  /* Laenge der Sequenz, die der Contig darstellt */
  GtUword seqlen;
  /* Wert der A-Statistik, um Contigs als REPEAT oder UNIQUE
     klassifizieren zu koennen;
     in Genom-Tools vom Typ float */
  float astat;
  /* abgeschaetzte Anzahl an Vorkommen des Contigs im Genom */
  float copynum;
  /* zur Klassifikation des Knotens: REPEAT, UNIQUE, ... */
  VertexClass vertexclass;
  bool hasconflictinglink;
  GtUword nofedges;
  /* Sammlung von Kanten, die von dem Contig abgehen */
  struct GtScaffoldGraphEdge   **edges;
  /* Markierung fuer Algorithmen; aus Genome-Tools entnommen siehe
  match/rdj-contigs-graph.c */
  GtContigsGraphMarks color;
};

/* Edge */
struct GtScaffoldGraphEdge
{
  /*  Knoten, zu dem die Kante fuehrt */
  struct GtScaffoldGraphVertex *pend;
  /* Kante, die genau in die andere Richtung fuehrt */
  struct GtScaffoldGraphEdge *ptwin;
  /* Informationen zu der Verbindung zwischen den Knoten */
  GtScaffoldGraphLink link;
  /* Markierung fuer Algorithmen */
  GtContigsGraphMarks color;
  /* Abschaetzung der Entfernung der verbundenen Contigs */
  Gtword dist;
  /* Standardabweichung von der abgeschaetzten Entfernung */
  float stddev;
  /* Anzahl der Distanzinformationen, die ein Anzeichen fuer die
  Verbindung der Contigs geben */
  GtUword numpairs;
  /* enthaelt die Richtung (Sense, Antisense) und welche
     Straenge die paired-Information enthalten (die gleiche
     Richtung oder das Reverse) */
  Direction direction;
  Composition composition;
};

/* Graph */
struct GtScaffoldGraph
{
  struct GtScaffoldGraphVertex **vertices;
  GtUword nofvertices;
  struct GtScaffoldGraphEdge **edges;
  GtUword nofedges;
};
\end{lstlisting}

\section{Verfeinerung des Algorithmus zur Filterung der Knoten}

\begin{itemize}
\item graph.visit() Funktion durchläuft alle Knoten (HashMap) und ruft
  auf jedem Knoten die übergebene Vistor-Funktion auf. Vorher wird
  previsit() und danach postvisit() aufgerufen. (Quelle
  ScaffoldGraph.h)
\item Es dürfte keine Probleme beim zusammenlegen der Filterfunktionen
  geben, da die Bedingungen nacheinander für jeden Knoten lokal
  geprüft werden können.
\item Es sollte beachtet werden, dass es gegebenfalls andere
  Ergebnisse geben könnte, wenn in einem späteren Schritt die vorher
  schon herausgefilterten Knoten noch beachtet werden.
\item Die repetitiven Knoten sollten schon bei der Konstruktion des
  Graphen herausgefiltert werden.
\item Die markierten Knoten und Kanten können nicht sofort gelöscht
  werden, da die restlichen Knoten noch nicht klassifiziert sind. Da
  die Klassifikation eines Knoten aber anhand aller Nachbarn
  durchgeführt wird, können die Knoten und Kanten noch nicht früher
  gelöscht werden.
\item Bei SGA wird gezählt, wie viele Knoten anhand welches Kriteriums
  gelöscht werden. Dies könnte auch noch eingebaut werden.
\end{itemize}

\begin{algorithm}[H]
  \ForEach{Knoten im Graph}{
    \ForEach{Kantenrichtung}{
      \ForEach{Kantenpaar $(A,B)$ in gleiche Richtung}{
        \If{AmbiguousOrdering($A,B,p\_cutoff$) {\bf and}
           Summe der estCopyNum der zugehörigen
           Endknoten $<$ cn-cutoff ist}
          {Markiere Endknoten mit kleineren
	   estCopyNum als polymorph. Markiere alle Sense-
           /Antisensekanten des polymorphen Knoten schwarz,
           so dass sie im nächsten Schritt nicht mitbeachtet
           werden.\;
           \tcp{bei polymorphen Knoten wird nur das erste
             polymorphe Kantenpaar markiert}
           \If{Knoten ist polymorph markiert}{
             break\;
           }
          }
        }
      \tcp{polymorphe Knoten müssen nicht mehr auf
        inkonsistente Kanten überprüft werden}
       \If{Knoten ist polymorph}
         {break\;}
       \ForEach{Kantenpaar in gleiche Richtung}{
         Berechne Overlap von nicht-schwarzen Kantenpaar.\;
       }
       \If{längster Overlap $>$ 400} {
	 Markiere alle Sense-/Antisensekanten rot\;
      }
    }
  }
  Lösche alle markierten Knoten und Kanten\;
  \caption{Zusammengefasste Filterfunktion (Schritt 4a und 4b vereinigt)}
\end{algorithm}

\begin{algorithm}[H]
  \KwData{Kante $A$ und Kante $B$, die auf eindeutige Ordnung geprüft werden
    sollen. Wahrscheinlichkeitsschwellenwert $p\_cutoff$}
  \KwResult{Ob die Kanten $A$ und $B$ nicht eindeutig geordnet werden können}
  $\mu = A.dist - B.dist$\;
  $\sigma^2 = A.\sigma^2 + B.\sigma^2$\;
  $t = \frac{-\mu}{\sigma\cdot\sqrt{2}}$\;
  $P_{AB} = \frac{1}{2} \cdot \left( 1 + \frac{2}{\sqrt{\pi}} \int_{0}^{t} \exp{-x^2}\mathrm dx\right)$\;
  $P_{BA} = 1 - P_{AB}$\;
  \Return $\max\{P_{AB}, P_{BA}\} \leq p\_cutoff$
  \caption{Funktion \textsc{AmbiguousOrdering}$(A, B, p\_cutoff)$}
\end{algorithm}

\section{Notizen zu dem Layout-Algorithmus}

\begin{itemize}
\item terminale Knoten: Knoten, die nur SENSE oder ANTISENES Kanten
  haben (Quelle: ScaffoldAlgorithms)
\item Zusammenhangskomponenten-Funktion wird in
  StringGraph/GraphSearchTree.h definiert
\item beim Walk für den Scaffold wird zuerst für jede
  Zusammenhangskomponente jeder Pfad zwischen terminalen Knoten mit
  einer Breitensuche (ohne heuristische Auswahl der Reihenfolge der
  Kindsknoten) berechnet. Dabei wird die Pfadlänge (Gap-Größe)
  minimiert. Als Layout für eine Zusammenhangskomponente wird dann
  der Pfad mit der längsten Sequenz (ohne Gaps) gewählt. (Quelle:
  ScaffoldGraph und ScaffoldWalk)
\end{itemize}

\subsection{Layout-Algorithmus}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwData{Graph}
  \KwResult{Graph ohne Knoten, die nicht zum bestem Walk gehören}
  Markiere alle Knoten schwarz\;
  Berechnung aller Connected Components\;
  \ForEach{Connected Component}{
    Berechne Menge der terminalen Knoten (mit ausschließlich SENSE oder ANTISENSE Kanten)\\
    \ForEach{Terminaler Knoten}{
      Berechne alle Walks\;
      \ForEach{Walk}{
        \If{Contig-Gesamtlänge > bislang beste Contig-Gesamtlänge}{
          Setze aktuellen Walk als bestWalk\;
        }
      }
    }
  }
  Setze alle Kanten des bestWalk weiß\;
  Lösche alle schwarzen Kanten\;
  \caption{Berechnung der Scaffolds (Schritt 6)}
\end{algorithm}

\begin{algorithm}[H]
  \SetAlgoLined
  \KwData{terminaler Startknoten}
  \KwResult{Alle von diesem Knoten möglichen Walks}
  Konstruktionsrichtung = Richtung der vom terminalen Knoten ausgehenden Kanten\;
  \ForEach{Alle vom Knoten ausgehenden Kanten (in Konstruktionsrichtung)}{
    Speichere Startkante und Distanz in Map (für spätere Traversierung)\\
    Schiebe Startkante und Distanz in Queue
  }
  \While{BFS über Queue nicht beendet}{
    \If{Distanz zu aktuell betrachtetem Knoten z < bisher ermittelte Distanz zu diesem Knoten {\bf OR} Knoten noch unbetrachtet}{
      \If{Keine Kanten mehr zu betrachten}{
        Schiebe Knoten in terminalSet
      }
      Speichere Kante und Distanz in Map\;
      Schiebe Startkante und Distanz in Queue\;
    }
  }
  \ForEach{Knoten in terminalSet}{
    Erzeuge Walk mithilfe einer Traversierung über die Map
  }
  \caption{Berechnung der Walks (Schritt 6.1)}
\end{algorithm}

\end{document}
